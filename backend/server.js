const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const { OpenAI } = require('openai');
const app = express();

// Naƒçten√≠ promƒõnn√Ωch prost≈ôed√≠ ze souboru .env
dotenv.config();

// Middleware
app.use(cors({
    origin: function (origin, callback) {
        // Seznam povolen√Ωch dom√©n
        const allowedOrigins = [
            'http://localhost:8888',
            'http://localhost:8000', 
            'http://localhost:3000',
            'http://127.0.0.1:8888',
            'http://127.0.0.1:8000',
            'http://127.0.0.1:3000'
        ];
        
        // Povol√≠ dom√©ny Netlify a Vercel (kter√© obsahuj√≠ tyto vzory)
        const isDevelopment = !origin || allowedOrigins.includes(origin);
        const isNetlify = origin && origin.includes('netlify.app');
        const isVercel = origin && origin.includes('vercel.app');
        const isLocalhost = origin && (origin.includes('localhost') || origin.includes('127.0.0.1'));
        
        if (isDevelopment || isNetlify || isVercel || isLocalhost) {
            callback(null, true);
        } else {
            console.log('CORS blokoval origin:', origin);
            callback(new Error('Not allowed by CORS'));
        }
    },
    methods: ['GET', 'POST', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    credentials: false
}));
app.use(express.json());

// Inicializace OpenAI klienta
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Konstanta s ID asistenta
const ASSISTANT_ID = 'asst_TND8x7S6HXvVWTTWRhAPfp75';

// ƒåasov√Ω limit pro zpracov√°n√≠ odpovƒõdi (15 minut)
const TIMEOUT_MS = 15 * 60 * 1000;

// Funkce pro ƒçi≈°tƒõn√≠ citaƒçn√≠ch znaƒçek z OpenAI odpovƒõdi
function cleanOpenAIResponse(text) {
  // Odstranƒõn√≠ citaƒçn√≠ch znaƒçek ve form√°tu „Äêƒç√≠slo‚Ä†source„Äë
  return text.replace(/„Äê\d+‚Ä†[^„Äë]*„Äë/g, '');
}

// Funkce pro ƒçek√°n√≠ na dokonƒçen√≠ bƒõhu asistenta
async function waitForRunCompletion(threadId, runId) {
  const startTime = Date.now();
  let runStatus = await openai.beta.threads.runs.retrieve(threadId, runId);
  
  while (runStatus.status !== 'completed' && runStatus.status !== 'failed' && Date.now() - startTime < TIMEOUT_MS) {
    // ƒåek√°n√≠ p≈ôed dal≈°√≠m dotazem na stav
    await new Promise(resolve => setTimeout(resolve, 1000));
    runStatus = await openai.beta.threads.runs.retrieve(threadId, runId);
    console.log(`Stav bƒõhu asistenta: ${runStatus.status}`);
    
    // Kontrola, zda nepot≈ôebujeme poskytnout dal≈°√≠ vstupy (nap≈ô. p≈ôi pou≈æit√≠ funkc√≠)
    if (runStatus.status === 'requires_action') {
      console.log('Asistent vy≈æaduje dal≈°√≠ akci - toto ≈ôe≈°en√≠ zat√≠m nepodporuje interaktivn√≠ funkce');
      await openai.beta.threads.runs.cancel(threadId, runId);
      throw new Error('Asistent vy≈æaduje dal≈°√≠ akci, co≈æ nen√≠ podporov√°no');
    }
  }
  
  // Kontrola dokonƒçen√≠ bƒõhu nebo timeout
  if (runStatus.status !== 'completed' && runStatus.status !== 'failed') {
    if (Date.now() - startTime >= TIMEOUT_MS) {
      console.error('Vypr≈°el ƒçasov√Ω limit pro zpracov√°n√≠ odpovƒõdi asistenta');
      await openai.beta.threads.runs.cancel(threadId, runId);
      throw new Error('Vypr≈°el ƒçasov√Ω limit pro zpracov√°n√≠ odpovƒõdi asistenta');
    }
  }
  
  return runStatus;
}

// Funkce pro vytvo≈ôen√≠ a zpracov√°n√≠ konverzace s asistentem
async function processWithAssistant(formData) {
  try {
    // 1. Vytvo≈ôen√≠ nov√©ho vl√°kna
    const thread = await openai.beta.threads.create();
    console.log(`Vytvo≈ôeno nov√© vl√°kno s ID: ${thread.id}`);

    // 2. P≈ôid√°n√≠ zpr√°vy do vl√°kna s daty formul√°≈ôe
    await openai.beta.threads.messages.create(thread.id, {
      role: "user",
      content: JSON.stringify(formData)
    });
    console.log("Zpr√°va s daty formul√°≈ôe byla p≈ôid√°na do vl√°kna");

    // 3. Spu≈°tƒõn√≠ asistenta na vl√°knu
    const run = await openai.beta.threads.runs.create(thread.id, {
      assistant_id: ASSISTANT_ID
    });
    console.log(`Spu≈°tƒõn asistent s ID: ${run.id}`);

    // 4. Polling pro z√≠sk√°n√≠ stavu bƒõhu asistenta
    let runStatus = await waitForRunCompletion(thread.id, run.id);

    if (runStatus.status === "completed") {
      // 5. Z√≠sk√°n√≠ odpovƒõdi od asistenta
      const messages = await openai.beta.threads.messages.list(thread.id);
      const assistantMessages = messages.data.filter(msg => msg.role === "assistant");
      
      if (assistantMessages.length > 0) {
        const latestMessage = assistantMessages[0].content[0].text.value;
        console.log("Z√≠sk√°na odpovƒõƒè od asistenta");
        
        // ULTRA ROBUSTN√ç JSON PARSING
        let jsonContent;
        
        console.log("üîç Raw odpovƒõƒè asistenta:", latestMessage);
        
        // Krok 1: Vyƒçi≈°tƒõn√≠ citaƒçn√≠ch znaƒçek
        let cleanedMessage = cleanOpenAIResponse(latestMessage);
        console.log("üßπ Po vyƒçi≈°tƒõn√≠ citac√≠:", cleanedMessage);
        
        // Krok 2: Odstranƒõn√≠ v≈°ech mo≈æn√Ωch prefix≈Ø a suffix≈Ø
        cleanedMessage = cleanedMessage.trim();
        
        // Krok 3: Pokus o extrakci JSON z r≈Øzn√Ωch form√°t≈Ø
        const extractionMethods = [
          // Metoda 1: JSON v markdown bloku s "json"
          () => {
            const regex = /```json\s*([\s\S]*?)\s*```/i;
            const match = regex.exec(cleanedMessage);
            return match ? match[1].trim() : null;
          },
          
          // Metoda 2: JSON v markdown bloku bez "json"
          () => {
            const regex = /```\s*([\s\S]*?)\s*```/;
            const match = regex.exec(cleanedMessage);
            return match ? match[1].trim() : null;
          },
          
          // Metoda 3: JSON mezi { a } (nejpornƒõj≈°√≠ mo≈æn√Ω JSON)
          () => {
            const startIndex = cleanedMessage.indexOf('{');
            const lastIndex = cleanedMessage.lastIndexOf('}');
            if (startIndex !== -1 && lastIndex !== -1 && lastIndex > startIndex) {
              return cleanedMessage.substring(startIndex, lastIndex + 1);
            }
            return null;
          },
          
          // Metoda 4: Cel√° zpr√°va jako JSON
          () => {
            return cleanedMessage;
          }
        ];
        
        let successful = false;
        
        for (let i = 0; i < extractionMethods.length; i++) {
          try {
            const extractedText = extractionMethods[i]();
            if (extractedText) {
              console.log(`üîß Pokus ${i + 1} - extrahovan√Ω text:`, extractedText);
              jsonContent = JSON.parse(extractedText);
              console.log(`‚úÖ √öSPƒöCH! Metoda ${i + 1} √∫spƒõ≈°nƒõ parsovala JSON`);
              successful = true;
              break;
            }
          } catch (parseError) {
            console.log(`‚ùå Metoda ${i + 1} selhala:`, parseError.message);
            continue;
          }
        }
        
        if (!successful) {
          console.error("üö® V≈†ECHNY METODY SELHALY!");
          console.error("Origin√°ln√≠ odpovƒõƒè:", latestMessage);
          console.error("Vyƒçi≈°tƒõn√° odpovƒõƒè:", cleanedMessage);
          
          // Fallback - zkus√≠me vytvo≈ôit pr√°zdn√Ω response
          jsonContent = {
            intro_text: "Bohu≈æel do≈°lo k chybƒõ p≈ôi zpracov√°n√≠ odpovƒõdi. Zkuste to pros√≠m znovu.",
            doporuƒçene_dotace: [],
            celkov√°_dotace: "0 Kƒç",
            dal≈°√≠_informace: {
              n√°rok_na_z√°lohu: false,
              mo≈ænosti_bonusu: []
            }
          };
          console.log("üìã Pou≈æit fallback response");
        }
        
        return {
          success: true,
          data: jsonContent
        };
      } else {
        throw new Error("Asistent neodpovƒõdƒõl ≈æ√°dnou zpr√°vou");
      }
    } else {
      throw new Error(`Bƒõh asistenta selhal se statusem: ${runStatus.status}`);
    }
  } catch (error) {
    console.error("Chyba p≈ôi komunikaci s asistentem:", error);
    
    // Fallback response pro p≈ô√≠pad √∫pln√©ho selh√°n√≠
    return {
      success: true,
      data: {
        intro_text: "Omlouv√°me se, do≈°lo k technick√© chybƒõ p≈ôi zpracov√°n√≠ va≈°eho dotazu. Zkuste to pros√≠m za chv√≠li znovu.",
        doporuƒçene_dotace: [],
        celkov√°_dotace: "0 Kƒç",
        dal≈°√≠_informace: {
          n√°rok_na_z√°lohu: false,
          mo≈ænosti_bonusu: ["Zkuste formul√°≈ô vyplnit znovu za nƒõkolik minut"]
        }
      }
    };
  }
}

// Validace vstupn√≠ch dat z formul√°≈ôe
function validateFormData(data) {
  // Kontrola, zda data existuj√≠
  if (!data) {
    throw new Error('Nebyla poskytnuta ≈æ√°dn√° data');
  }
  
  // Z√°kladn√≠ povinn√° pole
  const requiredFields = ['typ_nemovitosti', 'opatreni'];
  
  for (const field of requiredFields) {
    if (!data[field]) {
      throw new Error(`Chyb√≠ povinn√© pole: ${field}`);
    }
  }

  // Kontrola typu pole "opatreni" (mus√≠ b√Ωt pole)
  if (!Array.isArray(data.opatreni)) {
    throw new Error('Pole "opatreni" mus√≠ b√Ωt seznam');
  }
  
  // Kontrola, ≈æe je vybr√°no alespo≈à jedno opat≈ôen√≠
  if (data.opatreni.length === 0) {
    throw new Error('Mus√≠ b√Ωt vybr√°no alespo≈à jedno opat≈ôen√≠');
  }

  // Pro≈°la v≈°echny kontroly
  return true;
}

// Endpoint pro odesl√°n√≠ dat do OpenAI asistenta
app.post('/api/submit-dotace', async (req, res) => {
  try {
    const formData = req.body;
    console.log('P≈ôijata data formul√°≈ôe:', formData);

    // Validace dat
    try {
      validateFormData(formData);
    } catch (error) {
      console.error('Validaƒçn√≠ chyba:', error.message);
      return res.status(400).json({ 
        success: false, 
        error: error.message 
      });
    }

    // Zpracov√°n√≠ dat pomoc√≠ OpenAI asistenta
    try {
      const assistantResponse = await processWithAssistant(formData);
      return res.json(assistantResponse);
    } catch (error) {
      console.error('Chyba p≈ôi zpracov√°n√≠ asistentem:', error.message);
      return res.status(500).json({
        success: false,
        error: 'Do≈°lo k chybƒõ p≈ôi zpracov√°n√≠ v√Ωpoƒçtu, zkuste to pros√≠m znovu'
      });
    }
  } catch (error) {
    console.error('Neoƒçek√°van√° chyba:', error);
    return res.status(500).json({
      success: false,
      error: 'Do≈°lo k neoƒçek√°van√© chybƒõ, zkuste to pros√≠m znovu'
    });
  }
});

// Z√°kladn√≠ endpoint pro kontrolu funkƒçnosti serveru
app.get('/api/health', (req, res) => {
  res.json({ status: 'OK', message: 'Server bƒõ≈æ√≠' });
});

// Nastaven√≠ portu
const PORT = process.env.PORT || 3000;

// Spu≈°tƒõn√≠ serveru
app.listen(PORT, () => {
  console.log(`Server bƒõ≈æ√≠ na portu ${PORT}`);
  console.log(`OpenAI API kl√≠ƒç ${process.env.OPENAI_API_KEY ? 'JE' : 'NEN√ç'} nastaven`);
}); 